<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Neon Rhythm Dash</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
    html, body { margin: 0; width: 100%; height: 100%; overflow: hidden; font-family: Inter, Segoe UI, Arial, sans-serif; background: #070b18; }
    body { background: radial-gradient(circle at 20% 10%, #16284b 0%, #090f1e 45%, #060912 100%); }
    canvas { width: 100%; height: 100%; display: block; touch-action: none; }

    .hud { position: fixed; top: max(10px, env(safe-area-inset-top)); left: 50%; transform: translateX(-50%); z-index: 8; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
    .pill { background: rgba(8, 14, 32, 0.78); border: 1px solid rgba(120, 230, 255, 0.5); border-radius: 999px; padding: 8px 14px; min-width: 110px; text-align: center; font-weight: 700; color: #d8f8ff; box-shadow: 0 0 12px rgba(70, 180, 255, 0.25); }

    .menu { position: fixed; inset: 0; z-index: 10; display: grid; place-items: center; background: rgba(0, 0, 0, 0.55); backdrop-filter: blur(3px); }
    .menu.hidden { display: none; }
    .card { width: min(90vw, 560px); border-radius: 14px; padding: clamp(16px, 3vw, 28px); background: rgba(6, 10, 24, 0.94); border: 1px solid rgba(117, 226, 255, 0.6); box-shadow: 0 16px 40px rgba(0, 0, 0, 0.45); text-align: center; }
    h1 { margin: 6px 0 10px; color: #8df2ff; letter-spacing: 0.04em; }
    p { margin: 8px 0; color: #d4ecff; opacity: 0.96; }
    .btn { margin-top: 14px; border: 1px solid #89e8ff; background: linear-gradient(180deg, #1d4f7a, #0f2941); color: white; padding: 11px 18px; border-radius: 10px; cursor: pointer; font-weight: 700; width: min(260px, 80%); }
    .controls { margin-top: 10px; font-size: 0.92rem; opacity: 0.9; }

    .input-zone { position: fixed; left: 10px; right: 10px; bottom: max(10px, env(safe-area-inset-bottom)); z-index: 6; border: 1px dashed rgba(132, 230, 255, 0.38); border-radius: 12px; min-height: 58px; display: flex; align-items: center; justify-content: center; font-weight: 700; color: #caf4ff; background: rgba(3, 7, 18, 0.35); }
    @media (min-width: 920px) { .input-zone { min-height: 48px; } }
  </style>
</head>
<body>
  <canvas id="gameCanvas" aria-label="Neon rhythm platformer"></canvas>

  <div class="hud">
    <div id="scoreLabel" class="pill">Score: 0</div>
    <div id="bestLabel" class="pill">Best: 0</div>
    <div id="modeLabel" class="pill">Mode: Endless</div>
  </div>

  <div id="menu" class="menu">
    <div class="card">
      <h1 id="menuTitle">Neon Rhythm Dash</h1>
      <p id="menuText">Tap to jump on beat. Precision hitboxes, fast restart, and rhythm-locked obstacle flow.</p>
      <p>Last Score: <strong id="lastScore">0</strong> | Best: <strong id="menuBest">0</strong></p>
      <button id="startBtn" class="btn">Start Run</button>
      <p class="controls">Space / Click / Touch: Jump · P: Pause · H: Hitbox Debug · M: Mute</p>
    </div>
  </div>

  <div id="inputZone" class="input-zone">TAP / CLICK / SPACE TO JUMP</div>

  <script>
    (() => {
      "use strict";

      const CONFIG = {
        baseWidth: 1280,
        baseHeight: 720,
        fixedDt: 1 / 120,
        maxFrameDt: 0.05,
        targetFps: 60,
        inputBufferMs: 100,
        world: {
          gravity: 3000,
          jumpForce: -1050,
          groundHeight: 128,
          startSpeed: 420,
          maxSpeed: 880,
          speedRamp: 5.4
        },
        player: {
          size: 44,
          hitboxScale: 0.78,
          x: 250,
          deathAnimMs: 180
        },
        level: {
          chunkTiles: 24,
          tileSize: 48,
          spawnAheadPx: 2400,
          cleanupBehindPx: 400
        },
        rhythm: {
          bpm: 142,
          subdivisionWeights: [1, 0.5, 0.25]
        }
      };

      class InputManager {
        constructor() {
          this.lastPressMs = -1e9;
          this.pausedToggleRequested = false;
          this.debugToggleRequested = false;
          this.muteToggleRequested = false;
        }
        press(nowMs) { this.lastPressMs = nowMs; }
        isBuffered(nowMs) { return nowMs - this.lastPressMs <= CONFIG.inputBufferMs; }
        clearBuffer() { this.lastPressMs = -1e9; }
      }

      class Physics {
        static integrateBody(body, dt) {
          body.vy += CONFIG.world.gravity * dt;
          body.y += body.vy * dt;
        }
      }

      class CollisionSystem {
        static aabb(a, b) {
          return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
        }

        static triangleVsRect(tri, rect) {
          if (!this.aabb(rect, tri.aabb)) return false;
          const points = [
            { x: rect.x, y: rect.y },
            { x: rect.x + rect.w, y: rect.y },
            { x: rect.x, y: rect.y + rect.h },
            { x: rect.x + rect.w, y: rect.y + rect.h },
            { x: rect.x + rect.w * 0.5, y: rect.y + rect.h }
          ];
          for (const p of points) if (this.pointInTriangle(p, tri.p1, tri.p2, tri.p3)) return true;
          const rEdges = [
            [points[0], points[1]], [points[1], points[3]], [points[3], points[2]], [points[2], points[0]]
          ];
          const tEdges = [[tri.p1, tri.p2], [tri.p2, tri.p3], [tri.p3, tri.p1]];
          for (const re of rEdges) for (const te of tEdges) if (this.linesIntersect(re[0], re[1], te[0], te[1])) return true;
          return false;
        }

        static pointInTriangle(p, a, b, c) {
          const area = (v1, v2, v3) => (v1.x * (v2.y - v3.y) + v2.x * (v3.y - v1.y) + v3.x * (v1.y - v2.y));
          const A = area(a, b, c);
          const s = area(p, b, c) / A;
          const t = area(a, p, c) / A;
          const u = area(a, b, p) / A;
          return s >= -0.0001 && t >= -0.0001 && u >= -0.0001;
        }

        static linesIntersect(a, b, c, d) {
          const ccw = (p1, p2, p3) => (p3.y - p1.y) * (p2.x - p1.x) > (p2.y - p1.y) * (p3.x - p1.x);
          return ccw(a, c, d) !== ccw(b, c, d) && ccw(a, b, c) !== ccw(a, b, d);
        }
      }

      class Obstacle {
        constructor() { this.active = false; this.type = "block"; this.x = 0; this.y = 0; this.w = 0; this.h = 0; }
        setup(type, x, y, w, h) { this.active = true; this.type = type; this.x = x; this.y = y; this.w = w; this.h = h; return this; }
        getAABB() { return { x: this.x, y: this.y, w: this.w, h: this.h }; }
        getTriangle() {
          const p1 = { x: this.x, y: this.y + this.h };
          const p2 = { x: this.x + this.w * 0.5, y: this.y };
          const p3 = { x: this.x + this.w, y: this.y + this.h };
          return { p1, p2, p3, aabb: { x: this.x, y: this.y, w: this.w, h: this.h } };
        }
      }

      class ObstaclePool {
        constructor(size = 220) {
          this.pool = Array.from({ length: size }, () => new Obstacle());
          this.active = [];
        }
        acquire(type, x, y, w, h) {
          const item = this.pool.length ? this.pool.pop() : new Obstacle();
          this.active.push(item.setup(type, x, y, w, h));
          return item;
        }
        releaseAt(index) {
          const o = this.active[index];
          o.active = false;
          this.pool.push(o);
          this.active[index] = this.active[this.active.length - 1];
          this.active.pop();
        }
        reset() {
          for (let i = this.active.length - 1; i >= 0; i--) this.releaseAt(i);
        }
      }

      class Player {
        constructor(groundY) {
          this.size = CONFIG.player.size;
          this.hitboxScale = CONFIG.player.hitboxScale;
          this.x = CONFIG.player.x;
          this.y = groundY - this.size;
          this.vy = 0;
          this.alive = true;
          this.deathT = 0;
          this.rotation = 0;
          this.pulse = 0;
        }
        reset(groundY) {
          this.y = groundY - this.size;
          this.vy = 0;
          this.alive = true;
          this.deathT = 0;
          this.rotation = 0;
          this.pulse = 0;
        }
        getHitbox() {
          const m = (1 - this.hitboxScale) * 0.5 * this.size;
          return { x: this.x + m, y: this.y + m, w: this.size * this.hitboxScale, h: this.size * this.hitboxScale };
        }
      }

      class AudioManager {
        constructor() {
          this.ctx = null;
          this.master = null;
          this.bpm = CONFIG.rhythm.bpm;
          this.beatInterval = 60 / this.bpm;
          this.nextBeatTime = 0;
          this.started = false;
          this.enabled = true;
        }
        ensureContext() {
          if (this.ctx) return;
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          this.master = this.ctx.createGain();
          this.master.gain.value = 0.28;
          this.master.connect(this.ctx.destination);
        }
        start() {
          this.ensureContext();
          if (this.ctx.state === "suspended") this.ctx.resume();
          this.nextBeatTime = this.ctx.currentTime + 0.05;
          this.started = true;
        }
        setMuted(muted) {
          this.enabled = !muted;
          if (this.master) this.master.gain.value = muted ? 0 : 0.28;
        }
        tick() {
          if (!this.started || !this.enabled) return false;
          let beatHit = false;
          while (this.nextBeatTime < this.ctx.currentTime + 0.12) {
            this.scheduleBeat(this.nextBeatTime);
            this.nextBeatTime += this.beatInterval;
            beatHit = true;
          }
          return beatHit;
        }
        scheduleBeat(time) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = "triangle";
          osc.frequency.setValueAtTime(170, time);
          osc.frequency.exponentialRampToValueAtTime(240, time + 0.045);
          gain.gain.setValueAtTime(0.0001, time);
          gain.gain.exponentialRampToValueAtTime(0.08, time + 0.01);
          gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.08);
          osc.connect(gain);
          gain.connect(this.master);
          osc.start(time);
          osc.stop(time + 0.09);
        }
      }

      class LevelManager {
        constructor(pool, getGroundY) {
          this.pool = pool;
          this.getGroundY = getGroundY;
          this.mode = "endless";
          this.worldX = 0;
          this.lastSpawnX = 0;
          this.distance = 0;
          this.spikeStreak = 0;
          this.patterns = this.buildPatterns();
          this.prebuilt = [];
        }
        buildPatterns() {
          return [
            ["_", "s", "_", "_", "b", "_", "s", "_"],
            ["_", "s", "s", "_", "_", "b", "_", "_"],
            ["_", "b", "_", "s", "_", "s", "_", "_"],
            ["_", "s", "_", "b", "_", "_", "s", "_"],
            ["_", "q", "_", "_", "s", "_", "q", "_"],
            ["_", "s", "s", "s", "_", "_", "b", "_"],
            ["_", "_", "b", "_", "s", "_", "s", "_"],
            ["_", "s", "_", "s", "_", "b", "_", "_"]
          ];
        }
        reset() {
          this.worldX = 0;
          this.lastSpawnX = 0;
          this.distance = 0;
          this.spikeStreak = 0;
          this.pool.reset();
        }
        setMode(mode) { this.mode = mode; }
        update(dt, scrollSpeed, beatInterval) {
          this.worldX += scrollSpeed * dt;
          this.distance = this.worldX;
          const aheadTarget = this.worldX + CONFIG.level.spawnAheadPx;
          while (this.lastSpawnX < aheadTarget) {
            this.spawnSegment(scrollSpeed, beatInterval);
          }
          const removeBefore = this.worldX - CONFIG.level.cleanupBehindPx;
          for (let i = this.pool.active.length - 1; i >= 0; i--) {
            if (this.pool.active[i].x + this.pool.active[i].w < removeBefore) this.pool.releaseAt(i);
          }
        }
        spawnSegment(scrollSpeed, beatInterval) {
          const tile = CONFIG.level.tileSize;
          const groundY = this.getGroundY();
          const beatTiles = Math.max(1, Math.round((scrollSpeed * beatInterval) / tile));
          const pattern = this.mode === "prebuilt" && this.prebuilt.length ? this.prebuilt[(this.lastSpawnX / tile) % this.prebuilt.length | 0] : this.patterns[(Math.random() * this.patterns.length) | 0];
          for (let i = 0; i < pattern.length; i++) {
            const symbol = pattern[i];
            const x = this.lastSpawnX + i * tile * beatTiles;
            if (symbol === "s") {
              if (this.spikeStreak >= 4) continue;
              this.pool.acquire("spike", x, groundY - tile, tile, tile);
              this.spikeStreak++;
            } else if (symbol === "b") {
              this.pool.acquire("block", x, groundY - tile * 1.2, tile, tile * 1.2);
              this.spikeStreak = 0;
            } else if (symbol === "q") {
              this.pool.acquire("spike", x, groundY - tile * 0.5, tile * 0.5, tile * 0.5);
              this.spikeStreak = Math.min(4, this.spikeStreak + 1);
            } else {
              this.spikeStreak = 0;
            }
          }
          this.lastSpawnX += pattern.length * tile * beatTiles;
        }
      }

      class UIManager {
        constructor() {
          this.menu = document.getElementById("menu");
          this.menuTitle = document.getElementById("menuTitle");
          this.menuText = document.getElementById("menuText");
          this.startBtn = document.getElementById("startBtn");
          this.lastScore = document.getElementById("lastScore");
          this.menuBest = document.getElementById("menuBest");
          this.scoreLabel = document.getElementById("scoreLabel");
          this.bestLabel = document.getElementById("bestLabel");
          this.modeLabel = document.getElementById("modeLabel");
        }
        showMenu(title, text, score, best) {
          this.menu.classList.remove("hidden");
          this.menuTitle.textContent = title;
          this.menuText.textContent = text;
          this.lastScore.textContent = score;
          this.menuBest.textContent = best;
        }
        hideMenu() { this.menu.classList.add("hidden"); }
        updateHud(score, best, mode, paused) {
          this.scoreLabel.textContent = `Score: ${score | 0}`;
          this.bestLabel.textContent = `Best: ${best | 0}`;
          this.modeLabel.textContent = paused ? "Mode: Paused" : `Mode: ${mode === "endless" ? "Endless" : "Prebuilt"}`;
        }
      }

      class Game {
        constructor() {
          this.canvas = document.getElementById("gameCanvas");
          this.ctx = this.canvas.getContext("2d", { alpha: false });
          this.inputZone = document.getElementById("inputZone");
          this.input = new InputManager();
          this.audio = new AudioManager();
          this.ui = new UIManager();
          this.pool = new ObstaclePool();
          this.pixelPerfect = false;
          this.debugHitbox = false;
          this.state = "menu";
          this.best = +(localStorage.getItem("neon-rhythm-best") || 0);
          this.score = 0;
          this.acc = 0;
          this.lastTs = performance.now();
          this.scale = 1;
          this.w = CONFIG.baseWidth;
          this.h = CONFIG.baseHeight;
          this.groundY = this.h - CONFIG.world.groundHeight;
          this.player = new Player(this.groundY);
          this.level = new LevelManager(this.pool, () => this.groundY);
          this.scrollSpeed = CONFIG.world.startSpeed;
          this.beatPulse = 0;
          this.parallax = [0, 0, 0];
          this.bindEvents();
          this.resize();
          this.ui.updateHud(0, this.best, this.level.mode, false);
          this.ui.showMenu("Neon Rhythm Dash", "A polished rhythm platformer in one HTML file. Press Start.", 0, this.best);
          requestAnimationFrame(this.frame.bind(this));
        }

        bindEvents() {
          addEventListener("resize", () => this.resize());
          const press = () => this.input.press(performance.now());
          addEventListener("keydown", e => {
            if (e.code === "Space") { e.preventDefault(); press(); }
            if (e.code === "KeyP") this.input.pausedToggleRequested = true;
            if (e.code === "KeyH") this.input.debugToggleRequested = true;
            if (e.code === "KeyM") this.input.muteToggleRequested = true;
            if (e.code === "KeyE") this.level.setMode(this.level.mode === "endless" ? "prebuilt" : "endless");
          });
          this.canvas.addEventListener("pointerdown", press, { passive: true });
          this.inputZone.addEventListener("pointerdown", press, { passive: true });
          document.getElementById("startBtn").addEventListener("click", () => this.start());
        }

        resize() {
          const dpr = Math.min(2, devicePixelRatio || 1);
          const sw = innerWidth;
          const sh = innerHeight;
          const scale = Math.min(sw / CONFIG.baseWidth, sh / CONFIG.baseHeight);
          this.scale = scale;
          this.w = Math.round(CONFIG.baseWidth * scale);
          this.h = Math.round(CONFIG.baseHeight * scale);
          this.canvas.width = Math.round(this.w * dpr);
          this.canvas.height = Math.round(this.h * dpr);
          this.canvas.style.width = `${this.w}px`;
          this.canvas.style.height = `${this.h}px`;
          this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          this.groundY = this.h - CONFIG.world.groundHeight * scale;
          this.player.x = CONFIG.player.x * scale;
          this.player.size = CONFIG.player.size * scale;
          this.player.hitboxScale = CONFIG.player.hitboxScale;
          this.player.y = this.groundY - this.player.size;
        }

        start() {
          this.audio.start();
          this.state = "running";
          this.score = 0;
          this.scrollSpeed = CONFIG.world.startSpeed * this.scale;
          this.level.reset();
          this.player.reset(this.groundY);
          this.ui.hideMenu();
          this.lastTs = performance.now();
        }

        restart() {
          this.state = "running";
          this.score = 0;
          this.scrollSpeed = CONFIG.world.startSpeed * this.scale;
          this.level.reset();
          this.player.reset(this.groundY);
        }

        die() {
          if (!this.player.alive) return;
          this.player.alive = false;
          this.player.deathT = CONFIG.player.deathAnimMs;
          if (this.score > this.best) {
            this.best = this.score | 0;
            localStorage.setItem("neon-rhythm-best", String(this.best));
          }
        }

        update(dt, nowMs) {
          if (this.input.pausedToggleRequested) {
            this.input.pausedToggleRequested = false;
            if (this.state === "running") this.state = "paused";
            else if (this.state === "paused") this.state = "running";
          }
          if (this.input.debugToggleRequested) { this.input.debugToggleRequested = false; this.debugHitbox = !this.debugHitbox; }
          if (this.input.muteToggleRequested) { this.input.muteToggleRequested = false; this.audio.setMuted(this.audio.enabled); }

          if (this.state !== "running") return;

          this.audio.tick();
          const beatInterval = this.audio.beatInterval;
          this.beatPulse = Math.max(0, this.beatPulse - dt * 2.5);

          this.scrollSpeed = Math.min(CONFIG.world.maxSpeed * this.scale, this.scrollSpeed + CONFIG.world.speedRamp * this.scale * dt);
          this.level.update(dt, this.scrollSpeed, beatInterval);
          this.score = this.level.distance * 0.05;

          const onGround = this.player.y + this.player.size >= this.groundY - 0.01;
          if (onGround) {
            this.player.y = this.groundY - this.player.size;
            this.player.vy = Math.max(0, this.player.vy);
            if (this.input.isBuffered(nowMs)) {
              this.player.vy = CONFIG.world.jumpForce * this.scale;
              this.input.clearBuffer();
              this.beatPulse = 1;
            }
          }

          Physics.integrateBody(this.player, dt);
          if (this.player.y + this.player.size >= this.groundY) {
            this.player.y = this.groundY - this.player.size;
            if (this.player.vy > 0) this.player.vy = 0;
          }
          this.player.rotation += (this.player.vy !== 0 ? 5.3 : 2.4) * dt;

          const hb = this.player.getHitbox();
          for (let i = 0; i < this.pool.active.length; i++) {
            const o = this.pool.active[i];
            if (o.x > this.level.worldX + this.w + 60 || o.x + o.w < this.level.worldX - 50) continue;
            const hit = o.type === "spike" ? CollisionSystem.triangleVsRect(o.getTriangle(), hb) : CollisionSystem.aabb(hb, o.getAABB());
            if (hit) { this.die(); break; }
          }

          if (!this.player.alive) {
            this.player.deathT -= dt * 1000;
            if (this.player.deathT <= 0) {
              this.state = "menu";
              this.ui.showMenu("Run Failed", "Instant soft reset enabled. Press Start to run again.", this.score | 0, this.best);
            }
          }

          this.parallax[0] += this.scrollSpeed * dt * 0.14;
          this.parallax[1] += this.scrollSpeed * dt * 0.28;
          this.parallax[2] += this.scrollSpeed * dt * 0.45;
        }

        drawBackground() {
          const c = this.ctx;
          c.fillStyle = "#070d1d";
          c.fillRect(0, 0, this.w, this.h);
          const pulse = this.beatPulse * 0.25;
          c.fillStyle = `rgba(${20 + pulse * 130}, ${35 + pulse * 100}, ${75 + pulse * 100}, 1)`;
          c.fillRect(0, 0, this.w, this.h);

          for (let layer = 0; layer < 3; layer++) {
            const speed = 0.25 + layer * 0.2;
            const size = (80 + layer * 35) * this.scale;
            const y = this.h * (0.25 + layer * 0.19);
            const offset = -(this.parallax[layer] * speed % size);
            this.ctx.fillStyle = `rgba(80,190,255,${0.07 + layer * 0.05})`;
            for (let x = offset; x < this.w + size; x += size) this.ctx.fillRect(x, y, size * 0.55, 2 + layer);
          }

          const gy = this.groundY;
          c.fillStyle = "#0d1732";
          c.fillRect(0, gy, this.w, this.h - gy);
          c.fillStyle = "rgba(120,220,255,0.4)";
          c.fillRect(0, gy - 2, this.w, 2);
        }

        drawObstacles() {
          const c = this.ctx;
          const camX = this.level.worldX;
          for (let i = 0; i < this.pool.active.length; i++) {
            const o = this.pool.active[i];
            const sx = o.x - camX;
            if (sx + o.w < -5 || sx > this.w + 5) continue;
            c.shadowBlur = 12;
            c.shadowColor = "rgba(110,210,255,0.55)";
            if (o.type === "spike") {
              c.fillStyle = "#6ae2ff";
              c.beginPath();
              c.moveTo(sx, o.y + o.h);
              c.lineTo(sx + o.w * 0.5, o.y);
              c.lineTo(sx + o.w, o.y + o.h);
              c.closePath();
              c.fill();
            } else {
              c.fillStyle = "#63bcff";
              c.fillRect(sx, o.y, o.w, o.h);
            }
            c.shadowBlur = 0;
            if (this.debugHitbox) {
              c.strokeStyle = "#ff4477";
              c.lineWidth = 1;
              c.strokeRect(sx, o.y, o.w, o.h);
            }
          }
        }

        drawPlayer() {
          const c = this.ctx;
          const p = this.player;
          c.save();
          c.translate(p.x + p.size * 0.5, p.y + p.size * 0.5);
          c.rotate(p.rotation);
          c.shadowBlur = 18;
          c.shadowColor = "rgba(130,245,255,0.8)";
          c.fillStyle = p.alive ? "#a2f7ff" : "#ff5f8c";
          c.fillRect(-p.size * 0.5, -p.size * 0.5, p.size, p.size);
          c.shadowBlur = 0;
          c.restore();

          if (this.debugHitbox) {
            const hb = p.getHitbox();
            c.strokeStyle = "#7aff3a";
            c.strokeRect(hb.x, hb.y, hb.w, hb.h);
          }
        }

        render() {
          this.drawBackground();
          this.drawObstacles();
          this.drawPlayer();
          if (this.state === "paused") {
            this.ctx.fillStyle = "rgba(0,0,0,0.35)";
            this.ctx.fillRect(0, 0, this.w, this.h);
            this.ctx.fillStyle = "#ddf8ff";
            this.ctx.font = `700 ${34 * this.scale}px Inter, sans-serif`;
            this.ctx.fillText("PAUSED", this.w * 0.5 - 70 * this.scale, this.h * 0.5);
          }
          this.ui.updateHud(this.score, this.best, this.level.mode, this.state === "paused");
        }

        frame(ts) {
          const dt = Math.min(CONFIG.maxFrameDt, (ts - this.lastTs) / 1000);
          this.lastTs = ts;
          this.acc += dt;
          while (this.acc >= CONFIG.fixedDt) {
            this.update(CONFIG.fixedDt, ts);
            this.acc -= CONFIG.fixedDt;
          }
          this.render();
          requestAnimationFrame(this.frame.bind(this));
        }
      }

      new Game();
    })();
  </script>
</body>
</html>
